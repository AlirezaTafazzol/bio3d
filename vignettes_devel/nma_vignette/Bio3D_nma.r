#' # Supporting Material: Enhanced Methods for Normal Mode Analysis with Bio3D
#' ## Lars Skjaerven, Xin-Qiu Yao & Barry J. Grant

#+ preamble, include=FALSE, eval=FALSE
library(knitr)
spin('Bio3D_nma.r')
system("pandoc -o Bio3D_nma.pdf Bio3D_nma.md")


#' ## Background:
#' Bio3D[^1] is an R package that provides interactive tools for structural bioinformatics. The primary focus of Bio3D is the analysis of bimolecular structure, sequence and simulation data.
#'
#' Normal mode analysis (NMA) is one of the major simulation techniques used to probe large-scale motions in biomolecules. Typical application is for the prediction of functional motions in proteins. Version 2.0 of the Bio3D package includes extensive NMA facilities. These include a unique collection of multiple elastic network model force-fields (see Example 1 below), automated ensemble analysis methods (Example 2) and variance weighted NMA (Example 3). Here we demonstrate the use of these new features with working code that comprise complete executable examples[^2].
#'
#' [^1]: The latest version of the package, full documentation and further vignettes (including detailed installation instructions) can be obtained from the main Bio3D website: http://thegrantlab.org/bio3d/
#'
#' [^2]: This document contains executable code that generates all figures contained within this document. See help(vignette) within R for further details. 
#'

#'
#' ## Example 1A: Basic single structure normal mode analysis
#' Normal mode analysis (NMA) of a single protein structure is carried out by providing a PDB object to the function **nma()**. Here we load the Bio3D package and then download an example structure of hen egg white lysozyme (PDB id *1hel*) with the function **read.pdb()**:

#+ example1_A, results="hide"
library(bio3d)
pdb <- read.pdb("1hel")
modes <- nma(pdb)

#' The function call **nma()** will perform the normal mode calculation, and return a *nma* object. You can print a short summary of the *nma* object simply by calling function **print()**:

print(modes)

#' This reveals the function call resulting in the *nma* object along with the total number of stored normal modes. For PDB id *1hel* there are 129 amino acid residues, and thus $3*129=387$ modes in this object (in which the first six are trivial modes). The frequency of the next six lowest-frequency modes is also printed. Note that the *nma* object consist of a number of attributes listed on the _+attr:_ line. A complete description of these attributes can be found on the **nma()** functions help page accessible with the command: `?nma`.
#'
#' Similarly to function **print()** you can call **plot()** on the same *nma* object. This will give a quick overview of (1) the eigenvalues, (2) the mode frequencies, and (3) the atomic fluctuations (See Figure 1).

#+ fig1_a_1, fig.cap="Summary plot of NMA results" 
plot(modes)
 

#'
#' ## Example 1B: Multiple force fields for normal mode analysis
#' The main Bio3D normal mode analysis function, **nma()**, requires a set of coordinates, as obtained from the **read.pdb()** function, and the specification of a force field describing the interactions between constituent atoms. A large number of force fields are available. Details of these force fields can be obtained with the command `help(load.enmff)` and their usage is briefly demonstrated below.


# summary(pdb)

#+ help, eval=FALSE
help(load.enmff)

#+ example1_B, results="hide"
modes.a <- nma(pdb, ff="calpha")
modes.b <- nma(pdb, ff="anm")
modes.c <- nma(pdb, ff="pfanm")
modes.d <- nma(pdb, ff="calphax")
modes.e <- nma(pdb, ff="reach")

#+ example1_B_rmsip
rmsip(modes.a, modes.b)
## RMSIP matrix plot here with adjplot or similar...
#adjplot( rmsip(modes.a, modes.b, modes.c, modes.d, modes.e) )


#'
#' ## Example 2: Ensemble normal mode analysis
#' The analysis of multiple structures for a given target (e.g. protein family) can be accomplished with the nma.pdbs() function. This will take aligned input structures, as generated by the pdbaln() function for example, and perform NMA on each structure collecting the results in manner that facilitates the interoperation of similarity and dissimilarity trends in the structure set. Here we will analyze a collection of protein kinases (2A) and large set of transducin heterotrimeric G protein family members (2B). 

#'
#' ### Example 2A: Protein kinases 

#+ example2_A, cache=TRUE, results="hide"
# Select Protein Kinase PDB IDs
ids <- c("4b7t", "2exm", "1OPJ", 
         "4JAJ", "1A9U", "1tki", 
          "1phk", "1csn", "1lp4") 
         # "1m14", "3dnd", "2jdo", "1JKL", "1gng", "2src", "1OMW", "1b6c_D",

raw.files <- get.pdb(ids, path="raw_pdbs")
ids <- paste0(ids,"_A")
files <- pdbsplit( raw.files, ids )

# Alignment of structures
pdbs <- pdbaln(files)

# NMA on all structures
modes <- nma.pdbs(pdbs, full=TRUE)


#plot(modes)

#'
#' ### Note: Should we have a plot.enma() to simplify the below??
#'

#+ pkaM1, fig.cap="Ensemble NMA fluxtuations figure legend here"
## Plot fluctuation data
plot.bio3d(modes$fluctuations[1,], type="o", xlab="Residue Position")
for(i in 2:nrow(modes$fluctuations)) {
  lines(modes$fluctuations[i,], type='o', col=i)
}
lines(modes$fluctuations[3,], type='o', col=3)


#'
#' ### Example 2B: Transducin
#' 
#' This example will run **nma.pdbs()** on transducin family containing 53 PDB structures.

#' First, we download pre-compiled structure and alignment data for transducin.
#+ data, cache=TRUE
# We may think of puting this data (or a subset) within the package!
download.file("http://www-personal.umich.edu/~xinqyao/transducin.RData", 
              "transducin.RData")
load("transducin.RData")

#' The object **pdbs** contains the C-alpha atoms coordinates of the 53 structures with
#' atomic positions aligned based on the multiple sequence alignment. 
#+, cache=TRUE, results="hide"
nmodes <- nma.pdbs(pdbs)
ind <- grep("1TAG_A", pdbs$id)
pdb <- read.pdb("1tag")
resno <- pdbs$resno[ind, ]
resno[!is.na(resno)] <- pdb$atom[pdb$calpha,"resno"]
sse<-dssp(pdb)

#' Objects **gaps.atom** and **gaps.xyz** are prepared previously with calling
#' gap.inspect(pdbs\$ali) and gap.inspect(pdbs\$xyz), respectively. **ligs** annotates
#' the nucleotide state of each structure based on a preliminary inspection on the structure data, 
#' while **vcolors** accordingly colors nucleotide state with green (GDP) and red (GTP).
#' 
#+ example2_B, fig.cap="Atomic fluctuation of transducin predicted by NMA"
plot.bio3d(resno[gaps.atom$f.inds],
           nmodes$fluctuations[ind,], typ="n",
           xlab="Residue Position", sse=sse,
           xlim=c(1, max(as.numeric(resno[gaps.atom$f.inds]), na.rm=TRUE)),
           ylim=c(0, max(nmodes$fluctuations, na.rm=TRUE)))
for(i in which(ligs=="GDP")) {
  lines(resno[gaps.atom$f.inds],
        nmodes$fluctuations[i,], type='h', col=vcolors[i], lwd=5.0)
}
for(i in which(ligs=="GTP")) {
  lines(resno[gaps.atom$f.inds],
        nmodes$fluctuations[i,], type='h', col=vcolors[i], lwd=1.0)
}
text(x=176, y=1, label="SW I")
text(x=200, y=1.3, label="SW II")
text(x=210, y=2.2, label="SW III")

#' ### Note: Elements of the above plot again look like a job for a plot.enma()!!!

#' The inter-structure relationship can be characterized via comparing the modes predicted by NMA. 
#' The similarity of structures in terms of dynamic property is calculated with the root mean square
#' inner product (RMSIP) of low-frequency vibrational modes. As a comparison, we also calculated the
#' inter-structure root mean square deviation (RMSD) of the C-alpha atoms.
#+ example2_B2, fig.cap="Distribution of overlap value among transducin family (Do we need this figure?)"
rmsip.map <- nmodes$rmsip
rownames(rmsip.map) <- substr(basename(pdbs$id), 1, 6)
colnames(rmsip.map) <- substr(basename(pdbs$id), 1, 6)
hist(rmsip.map, breaks=70)
#+ example2_B3, fig.cap="RMSIP matrix of transducin family"
heatmap((1-rmsip.map), labRow=ligs, symm=TRUE)

#+, cache=TRUE
rmsd.map <- rmsd(pdbs$xyz, a.inds=gaps.xyz$f.inds, fit=TRUE)
dimnames(rmsd.map) <- dimnames(rmsip.map)
#+ example2_B4, fig.cap="RMSD matrix of transducin family"
heatmap(rmsd.map, labRow=ligs, symm=TRUE)

#'
#' ## Example 3: Variance weighted normal mode analysis
#' Some introductory text here on the notion of variance weighted NMAâ€¦

#'
#' ### Example 3A: GroEL
#'

#'
#' ### Example 3B: Transducin
#' 
#' This example will run **nma()** on transducin with various variance weighted force constants. 
#' The modes predicted by NMA will be compared with PCA results over the transducin family.

#' First, download data and wrap a function for making variance weights:
#+, cache=TRUE
# We may think of puting the online data somewhere else!!!
download.file("http://www-personal.umich.edu/~xinqyao/transducin.RData", 
              "transducin.RData")
load("transducin.RData")

mk.weights <- function(xyz) {
  # weights <- mk.weights(xyz)
  natoms <- ncol(xyz) / 3
  all <- array(0, dim=c(natoms,natoms,nrow(xyz)))
  for( i in 1:nrow(xyz) ) {
    dists <- dist.xyz(xyz[i,])
    all[,,i] <- dists
  }
  all.vars <- apply(all, 1:2, var)
  cat( paste("Max:", round(max(all.vars),2),
             "  Min:", round(min(all.vars),2) ),"\n" )
  return(1 - (all.vars / max(all.vars)))
}

#' Then, we take one structure for each GDP and GTP state, and run **nma()** with force field **calpha**.
#' The PDB objects **gdp** and **gtp** contains the structural information for the C-alpha atoms of 
#' transducin in GDP (PDB ID 1TAG) and GTP (PDB ID 1TND) states, respectively. The coordinates 
#' in **gdp** and **gtp** were fitted to the **pdbs** object based on all non-gap C-alpha positions. 
#+, results="hide"
inds <- sapply(c("1TAG_A", "1TND_B"), grep, pdbs$id)
inds.gdp <- atom.select(gdp, resno=pdbs$resno[inds[1], gaps.atom$f.inds])
inds.gtp <- atom.select(gtp, resno=pdbs$resno[inds[2], gaps.atom$f.inds])

#+
modes.gdp <- nma(gdp, inds=inds.gdp, fc.weights=NULL)
modes.gtp <- nma(gtp, inds=inds.gtp, fc.weights=NULL)

#' Now, we calculate the pairwise distance variance based on the structure ensemble 
#' with the wrapped function mentioned above. This will be used to weight the force constants
#' in the elastic network model. The object **xyz** is a numeric matrix containing 
#' aligned cartesian coordinates all fitted to the first structure in **pdbs**, 
#' xyz <- pdbfit(pdbs).
weights <- mk.weights(xyz[, gaps.xyz$f.inds])

modes.gdp.b <- nma(gdp, inds=inds.gdp, fc.weights=weights**100)
modes.gtp.b <- nma(gtp, inds=inds.gtp, fc.weights=weights**100)

#' To evaluate the results, we calculate the overlap (square dot product) between modes predicted by 
#' variance weighted or non-weighted NMA and the first principle component from PCA (contained
#' in the object **pc.xray** returned by calling **pca.xyz(xyz[, gaps.xyz$f.inds])**.
oa <- overlap(modes.gdp, pc.xray$U[,1])
ob <- overlap(modes.gtp, pc.xray$U[,1])
oc <- overlap(modes.gdp.b, pc.xray$U[,1])
od <- overlap(modes.gtp.b, pc.xray$U[,1])

#+, fig.cap="Variance weighted force constants improve NMA prediction"
plot(oa$overlap.cum, type='o', ylim=c(0,1), col="darkgreen", lwd=2, xlab="Mode", 
     ylab="Cummulative overlap")
lines(ob$overlap.cum, type='o', ylim=c(0,1), col="red", lwd=2)
lines(oc$overlap.cum, type='b', ylim=c(0,1), col="darkgreen", lwd=2)
lines(od$overlap.cum, type='b', ylim=c(0,1), col="red", lwd=2)
text(20, oa$overlap.cum[20], label=round(oa$overlap.cum[20], 2), pos=3)
text(20, ob$overlap.cum[20], label=round(ob$overlap.cum[20], 2), pos=3)
text(20, oc$overlap.cum[20], label=round(oc$overlap.cum[20], 2), pos=3)
text(20, od$overlap.cum[20], label=round(od$overlap.cum[20], 2), pos=3)
legend(x=2, y=1.0, pch=1, lty=c(1, 1, 2, 2), col=c("darkgreen", "red", 
       "darkgreen", "red"), legend=c("GDP", "GTP", "Weighted GDP", "Weighted GTP"))

#'
#' ## Document Details
#' This document is shipped with the Bio3D package in both latex and PDF formats. All code can be extracted and automatically executed to generate Figures and/or PDF with the following commands:

#+ close, include=TRUE, eval=FALSE
library(knitr)
spin('Bio3D_nma.r')
system("pandoc -o Bio3D_nma.pdf Bio3D_nma.md")

#'
#' ## Information About the Current Bio3D Session
#'
print(sessionInfo(), FALSE)
