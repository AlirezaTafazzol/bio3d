


<<loadtransducin, eval=FALSE>>=
## Download and split transducin PDB files
ids<-c("1TND_B","1AGR_A","1FQJ_A","1TAG_A","1GG2_A","1KJY_A")
raw.files <- get.pdb(ids)
files <- pdbsplit(raw.files, ids)

## Alignment
pdbs <- pdbaln(files)
@

\subsubsection{The Kinesin Molecular Motor}
We also utilize the included kinesin dataset especially for demostrating sequence analysis for a protein family with diverse sequences.  A related dataset formed the basis of the work described in \citep{grant07}.  Briefly, kinesins are molecular motor proteins responsible for the ATP dependent transport of cellular cargo along microtubules.  Kinesin family members have been found in all eukaryotic organisms, where they contribute to the transport of molecules and organelles, organisation and maintenance of the cytoskeleton, and the segregation of genetic material during mitosis and meiosis. 

The defining attribute of kinesin family members is the possession of one or more globular motor domains. These $\sim$350 residue domains are responsible for ATP hydrolysis, microtubule binding and force production. The current dataset consists of kinesin motor domain sequence and structural data and can be loaded with the command \texttt{data(kinesin)}:

<<kinesin, eval=FALSE>>=
data(kinesin)
attach(kinesin)
@ 



#########
\section{Sequence Conservation Analysis}
In this section, we illustrate several functions related to sequence conservation analysis with the kinesin dataset. The \texttt{read.fasta} and  \texttt{write.fasta} functions can be used to read and write aligned and non aligned sequences in FASTA format. 

\subsection{Sequence Alignment}
The \texttt{seqaln()} function permits the alignment of multiple sequences as obtained from the \texttt{read.fasta()}.  A simple alignment procedure for the sequences in the file \emph{unaligned.fa} would involve the commands:
<<eval=FALSE>>=
aln <-  seqaln(read.fasta("unaligned.fa")) 
@ 

\subsection{Residue Conservation Analysis}
To assess the level of sequence conservation at each position in
an alignment, the \emph{similarity}, \emph{identity}, and \emph{entropy} per position can be calculated with the \texttt{conserv()} function.

The \emph{similarity} is defined as the average of the similarity
scores of all pairwise residue comparisons for that position in
the alignment, where the similarity score between any two residues
is the score value between those residues in the chosen
substitution matrix.

The \emph{identity} i.e. the preference for a specific amino acid to be
found at a certain position, is assessed by averaging the identity
scores resulting from all possible pairwise comparisons at that
position in the alignment, where all identical residue comparisons
are given a score of 1 and all other comparisons are given a value
of 0.

\emph{Entropy} is based on Shannon's information entropy. See the
\texttt{entropy} function for further details.

<<>>=
data(kinesin)
attach(kinesin, warn.conflicts=FALSE)
sim <- conserv(x=pdbs$ali, method="similarity", sub.matrix="bio3d")
write.fasta(pdbs, file="kinesin.fa")
aln <- read.fasta("kinesin.fa")
@ 

\paragraph{Side-note:} The last two lines in above code snippet are just for illustrating the usage of the function \texttt{read.fasta()}. In examples all through the document, the \texttt{aln} object can be replaced by \texttt{pdbs} because the latter contains all the components of the former.

\begin{center}
<<fig=TRUE,echo=TRUE, fig.cap="Residue conservation of kinesin protein family">>=
pdb2 <- read.pdb("1bg2")
sse2 <- dssp(pdb2, resno=FALSE)
plot.bio3d(sim[!is.gap(aln$ali[1,])], sse=sse2, xlab="Residue", ylab="Similarity")
@ 
\end{center}

The \texttt{aln2html()} function renders a sequence alignment as coloured HTML suitable for viewing with a web browser.
<<eval=FALSE>>=
write.fasta(seqs=aln$ali[,379:385], file="eg.fa")
aln2html(aln, append=FALSE, file="eg.html")
aln2html(aln, colorscheme="ent", file="eg.html")
@ 

\paragraph{Question:}What is the relationship between sequence conservation and structural variance?

\subsection{Inter-sequence Evolutionary Analysis}

\paragraph{Pairwise identity analysis}
Pairwise identity analysis is an efficient way to remove too close sequences in the analysis, with the help of the funciton \texttt{ide.filter()}:
<<fig=TRUE, fig.cap="Sequence identity distribution before and after filter (cutoff=0.6)">>=
ide.mat <- seqidentity(pdbs)

# Histogram of pairwise identity values
op <- par(no.readonly=TRUE)
par(mfrow=c(2,1))
hist(ide.mat[upper.tri(ide.mat)], breaks=30,xlim=c(0,1),
     main="Sequence Identity", xlab="Identity")

k <- ide.filter(ide=ide.mat, cutoff=0.6)
ide.cut <- seqidentity(pdbs$ali[k$ind,])
hist(ide.cut[upper.tri(ide.cut)], breaks=10, xlim=c(0,1),
     main="Sequence Identity", xlab="Identity")
par(op)
@

\paragraph{Consensus sequence}
Determines the consensus sequence for a given alignment at a given identity cutoff value. For clarity, we take the positions from 50 to 100 of the protein:
<<fig=TRUE, fig.cap="Consensus sequence identified for kinesin protein family">>=
con <- consensus(aln$ali[,50:100])
print(con$seq)

# Plot residue frequency matrix
col <- mono.colors(32)
aa  <- rev(rownames(con$freq))

image(x=1:ncol(con$freq),
      y=1:nrow(con$freq),
      z=as.matrix(rev(as.data.frame(t(con$freq)))),
      col=col, yaxt="n", xaxt="n",
      xlab="Alignment Position", ylab="Residue Type")

# Add consensus along the axis
axis(side=1, at=seq(0,length(con$seq),by=5), labels=seq(50, 100, by=5))
axis(side=2, at=c(1:22), labels=aa)
axis(side=3, at=c(1:length(con$seq)), labels =con$seq)
axis(side=4, at=c(1:22), labels=aa)
grid(length(con$seq), length(aa))
box()

# Add consensus sequence
for(i in 1:length(con$seq)) {
  text(i, which(aa==con$seq[i]),con$seq[i],col="white")
}

# Add lines for residue type separation
abline(h=c(2.5,3.5, 4.5, 5.5, 3.5, 7.5, 9.5,
         12.5, 14.5, 16.5, 19.5), col="gray")
@

\paragraph{Question:}What can we learn from a combined comparative sequence and structure analysis?

